#!/usr/bin/env python

# To test this recipe run:
# echo "PINBOARD_TOKEN=..." > config.env
# eval $(egrep -v '^#' config.env | xargs) ebook-convert pinboard-to-kindle.recipe test.mobi --output-profile kindle_pw3 --verbose

__license__ = "MIT"
__copyright__ = "2020, Christian Hans"
__website__ = "https://github.com/christianhans/pinboard-to-kindle"

#
# Config
#
## Maximum number of unread Pinboard bookmarks to fetch
MAX_ARTICLES = 50

## Temporary folder to use for downloading bookmark's page content
FETCH_ARTICLE_TMP_PATH = "/tmp"

import os
import sys
import re
import urllib
import json
import subprocess
import uuid


class PinboardRecipe(BasicNewsRecipe):
    title = "Pinboard"
    description = "Generate an ebook of unread Pinboard bookmarks."
    __author__ = "Christian Hans"

    auto_cleanup = False
    no_stylesheets = True
    remove_javascript = True
    articles_are_obfuscated = True
    encoding = "utf8"

    downloaded_file_paths = {}

    def _get_settings(self):
        res = {}
        pinboard_token = os.environ.get("PINBOARD_TOKEN")
        if not pinboard_token:
            self.abort_recipe_processing(
                "Please set PINBOARD_TOKEN environment variable."
            )
        res["pinboard_token"] = pinboard_token

        to_send_tag = os.environ.get("TO_SEND_TAG")
        if not to_send_tag:
            self.abort_recipe_processing(
                "Please set TO_SEND_TAG environment variable."
            )
        res["to_send_tag"] = to_send_tag

        sent_tag = os.environ.get("SENT_TAG")
        res["sent_tag"] = sent_tag if sent_tag else ""

        return res

    def _get_bookmarks(self, token, to_send_tag):
        params = urllib.urlencode(
            {
                "tag": to_send_tag if to_send_tag else "",
                "format": "json",
                "auth_token": token,
            }
        )
        response = urllib.urlopen("https://api.pinboard.in/v1/posts/all?" + params)
        bookmarks = json.loads(response.read().decode('utf-8-sig'))
        bookmarks = [b for b in bookmarks if (b["toread"] == "yes")]
        bookmarks = bookmarks[:MAX_ARTICLES]
        if len(bookmarks) == 0:
            self.abort_recipe_processing("No unread Pinboard bookmarks.")
        return bookmarks

    def _mark_bookmark_as_sent(self, bookmark, token, to_send_tag, sent_tag):

        if (not to_send_tag) or (not sent_tag):
            return
        print("Updating Pinboard tags: {}".format(bookmark["href"]))
        tags = bookmark["tags"].split()
        if to_send_tag in tags:
            tags.remove(to_send_tag)
        if not sent_tag in tags:
            tags.append(sent_tag)
        params = urllib.urlencode(
            {
                "url": bookmark["href"],
                "description": bookmark["description"],
                "extended": bookmark["extended"],
                "tags": " ".join(tags),
                "dt": bookmark["time"],
                "shared": bookmark["shared"],
                "toread": bookmark["toread"],
                "replace": "yes",
                "format": "json",
                "auth_token": token,
            }
        )
        urllib.urlopen("https://api.pinboard.in/v1/posts/add?" + params)

    def _fetch_article_moz_readability(self, url):
        downloaded_file_path = os.path.join(
            FETCH_ARTICLE_TMP_PATH, "{}.html".format(uuid.uuid1())
        )
        self.downloaded_file_paths[url] = downloaded_file_path

        print("Downloading: {}".format(url))

        subprocess.call(
            [
                "p2k",
                "download",
                url,
                downloaded_file_path 
            ]
        )

        return downloaded_file_path

    def _get_article_metadata(self, article_file_path):
        res = {}
        with open(article_file_path, "r") as f:
            html = f.read()
        match = re.search(
            '<[^>]+ id="pb-to-kindle-article-title">(.*?)</[^>]+>', html, re.IGNORECASE
        )
        if match:
            res["title"] = match.group(1)
        match = re.search(
            '<[^>]+ id="pb-to-kindle-article-metadata">(.*?)</[^>]+>',
            html,
            re.IGNORECASE,
        )
        if match:
            res["metadata"] = match.group(1)
        return res

    def get_obfuscated_article(self, url):
        """ Let Calibre download images and other media in downloaded html files """
        return self.downloaded_file_paths.get(url)

    def parse_index(self):
        articles = []

        settings = self._get_settings()

        bookmarks = self._get_bookmarks(settings["pinboard_token"], settings["to_send_tag"])
        for bookmark in bookmarks:
            url = bookmark["href"]
            try:
                article_file_path = self._fetch_article_moz_readability(url)
                article_info = self._get_article_metadata(article_file_path)
            except:
                print("Error fetching URL: {}".format(url))
                continue

            self._mark_bookmark_as_sent(bookmark, settings["pinboard_token"], settings["to_send_tag"], settings["sent_tag"])

            articles.append(
                {
                    "title": article_info.get("title", ""),
                    "url": url,
                    "description": article_info.get("metadata", ""),
                    # "date": "February 20th, 2020",
                }
            )

        return [("Pinboard", articles)]

    def cleanup(self):
        for file_path in self.downloaded_file_paths.values():
            if not os.path.exists(file_path):
                continue
            print("Removing temporary file: {}".format(file_path))
            os.remove(file_path)
